-- MIPS Instruction Memory Initialization File
-- Experimento 05 - Teste completo da ULA
Depth = 256;
Width = 32;
Address_radix = HEX;
Data_radix = HEX;
Content
Begin
-- ============================================
-- PROGRAMA DE TESTE - EXPERIMENTO 05
-- Teste de todas as operações da ULA
-- ============================================

-- ============================================
-- TESTE 1: Operações Lógicas (AND, OR)
-- ============================================
-- Registradores iniciais: $2=2, $3=3
	00: 00430024; 	-- and $4,$2,$3   ; $4 = 0x2 & 0x3 = 0x2
	01: 00432825; 	-- or  $5,$2,$3   ; $5 = 0x2 | 0x3 = 0x3

-- ============================================
-- TESTE 2: Operações Aritméticas (ADD, SUB)
-- ============================================
	02: 00433020; 	-- add $6,$2,$3   ; $6 = 2 + 3 = 5
	03: 00623822; 	-- sub $7,$3,$2   ; $7 = 3 - 2 = 1
	04: 00424022; 	-- sub $8,$2,$2   ; $8 = 2 - 2 = 0 (Zero=1)

-- ============================================
-- TESTE 3: Comparação (SLT)
-- ============================================
	05: 0043482A; 	-- slt $9,$2,$3   ; $9 = (2 < 3) = 1
	06: 0062502A; 	-- slt $10,$3,$2  ; $10 = (3 < 2) = 0
	07: 0042582A; 	-- slt $11,$2,$2  ; $11 = (2 < 2) = 0

-- ============================================
-- TESTE 4: Integração com LW/SW
-- ============================================
	08: 8C0C0000; 	-- lw $12,0($0)   ; $12 = memory[0] = 0x55555555
	09: 8C0D0004; 	-- lw $13,4($0)   ; $13 = memory[1] = 0xAAAAAAAA
	0A: 018D7020; 	-- add $14,$12,$13; $14 = 0x55555555 + 0xAAAAAAAA = 0xFFFFFFFF
	0B: AC0E0008; 	-- sw $14,8($0)   ; memory[2] = 0xFFFFFFFF
	0C: 8C0F0008; 	-- lw $15,8($0)   ; $15 = memory[2] = 0xFFFFFFFF (verifica SW)

-- ============================================
-- TESTE 5: Branch com Zero flag (BEQ)
-- ============================================
	0D: 00020820; 	-- add $1,$0,$2   ; $1 = 0 + 2 = 2
	0E: 00021020; 	-- add $2,$0,$2   ; $2 = 0 + 2 = 2 (mantém em 2)
	0F: 10220002; 	-- beq $1,$2,2    ; Se $1==$2, pula 2 (para 0x12)
	10: 00001820; 	-- add $3,$0,$0   ; $3 = 0 (NÃO EXECUTA - desvio)
	11: 00002020; 	-- add $4,$0,$0   ; $4 = 0 (NÃO EXECUTA - desvio)
	12: 00222822; 	-- sub $5,$1,$2   ; $5 = 2 - 2 = 0 (EXECUTA após desvio)

-- ============================================
-- TESTE 6: AND com padrões alternados
-- ============================================
	13: 8C100000; 	-- lw $16,0($0)   ; $16 = 0x55555555
	14: 8C110004; 	-- lw $17,4($0)   ; $17 = 0xAAAAAAAA
	15: 02118824; 	-- and $17,$16,$17; $17 = 0x55555555 & 0xAAAAAAAA = 0

-- ============================================
-- TESTE 7: OR com padrões alternados
-- ============================================
	16: 8C120000; 	-- lw $18,0($0)   ; $18 = 0x55555555
	17: 8C130004; 	-- lw $19,4($0)   ; $19 = 0xAAAAAAAA
	18: 02539825; 	-- or $19,$18,$19 ; $19 = 0x55555555 | 0xAAAAAAAA = 0xFFFFFFFF

-- ============================================
-- TESTE 8: SUB resultando em negativo (SLT prep)
-- ============================================
	19: 00C3A022; 	-- sub $20,$6,$3  ; $20 = 5 - 3 = 2
	1A: 0066A822; 	-- sub $21,$3,$6  ; $21 = 3 - 5 = -2 (0xFFFFFFFE)

-- ============================================
-- TESTE 9: SLT com negativos
-- ============================================
	1B: 02B5B02A; 	-- slt $22,$21,$21; $22 = (-2 < -2) = 0
	1C: 02C6B82A; 	-- slt $23,$22,$6  ; $23 = (0 < 5) = 1

-- ============================================
-- Resto: NOP
-- ============================================
	[1D..FF]: 00000000; -- nop (sll $0,$0,0)

End;